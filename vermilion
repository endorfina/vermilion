#!/bin/bash

readonly PROGNAME="${0##*/}"

usage() {
    cat << _EOF
$PROGNAME <cmd> [OPTIONS] ...

Available commands:
    add examples:
        $PROGNAME add git - will keep a repo up to date and nothing else.
        $PROGNAME add cmake - will run cmake and build upon new git pull.
        $PROGNAME add make target all - will run make upon new git pull.

    mark:
        Marks the current repo for a rebuild upon a subsequent upgrade call.

    post, postbuild:
        Will run specified commands upon successful git pull AND build.
        ex. $PROGNAME postbuild cp a.out ^/.local/bin/
        Note: ^/ is equivalent to \$HOME. It helps with portability.

    up, upgrade:
        Runs git fetch on everything and builds if new.

    prep, prepare:
        Checks if all repos actually exist and runs git clone if one doesn't.
        The parent directory must still be present.

Feel free to ask and/or contribute on github! :)
https://github.com/endorfina/vermilion

_EOF
}

test $# -eq 0 && usage && exit 1

readonly VERMILION_FILE_LIST_FILENAME="vermilion_record"
readonly VERMILION_FILE_LIST="${HOME}/.config/$VERMILION_FILE_LIST_FILENAME"
readonly VERMILION_FILE_LIST_TMP="/tmp/${VERMILION_FILE_LIST_FILENAME}.$(whoami)"
readonly VERMILION_FILE_LAST_SUCCESS=".vermilion_last_success"
readonly VERMILION_CFLAGS="-march=native -O2 -pipe"
readonly VERMILION_CXXFLAGS="-march=native -O3"
readonly VERMILION_TARGET="$1"
shift
readonly BASIC_ACCESS_SED="s/^\\s*#.*//;/^\\s*\$/d"
readonly TAG_POST_BEGIN="v^post^n"
readonly TAG_POST_END="v\$post\$n"
readonly TAG_POST_BEGIN_ESC="v\\^post\\^n"
readonly TAG_POST_END_ESC="v\\\$post\\\$n"
readonly TAG_DEP_BEGIN="v^dep^n"
readonly TAG_DEP_END="v\$dep\$n"
readonly TAG_DEP_BEGIN_ESC="v\\^dep\\^n"
readonly TAG_DEP_END_ESC="v\\\$dep\\\$n"


# Try using chroot-git then git from the host system
if command -v chroot-git &>/dev/null; then
	VERMILION_GIT_CMD=$(command -v chroot-git)
elif command -v git &>/dev/null; then
	VERMILION_GIT_CMD=$(command -v git)
else
    echo "neither chroot-git or git are available in your system!"
    exit 1
fi

readonly VERMILION_GIT_CMD

get_dir() {
    readonly local RE="^\^/(.+)"
    local escaped=$(echo "$1" | sed "s/%SPACE%/ /g")
    [[ "$escaped" =~ $RE ]] && \
        echo -n "${HOME}/${BASH_REMATCH[1]}" || \
        echo -n "$escaped"
}

get_dir_current() {
    local readonly RE="^(${HOME})/(.+)"
    local FILENAME=$(pwd | sed "s/ /%SPACE%/g")
    [[ "$FILENAME" =~ $RE ]] && \
        echo "^/${BASH_REMATCH[2]}" || \
        echo "$FILENAME"
}

prepare() {
    local DIR=$(get_dir "$1")
    local BASENAME=$(basename $DIR)
    local ORIGIN="$2"

    if test ! -d $DIR && cd $(dirname "$DIR"); then
        $VERMILION_GIT_CMD clone --recurse-submodules $ORIGIN $BASENAME &>/dev/null && \
        echo "Fetching $BASENAME: complete"
    fi

    cd $DIR || (echo "Can't build $DIR" 1>&2; exit 1)
}

run_make() {
    local MAK_TARGET=
    while test $# -gt 0; do
        local VERCMD="$1"
        shift
        case "$VERCMD" in
            cxxflags)
                export "$1"="$VERMILION_CXXFLAGS"
                shift
                ;;
            cflags)
                export "$1"="$VERMILION_CFLAGS"
                shift
                ;;
            target)
                MAK_TARGET="$1"
                shift
                ;;
        esac
    done
    test -n "$MAK_TARGET" && \
        make "$MAK_TARGET" || \
        make
}

upgrade() {
    readonly local DIR=$(get_dir "$1")
    readonly local ORIGIN="$2"
    shift 2

    local POST_BUILD=()

    if [[ "$1" == $TAG_POST_BEGIN ]]; then
        shift
        readonly local HOME_ESCAPED=$(echo "${HOME}" | sed "s:\\/:\\\\/:g")
        while test $# -gt 0 && test "$1" != "$TAG_POST_END"; do
            POST_BUILD+=("$(echo "$1" | sed "s:^\\^\\/:${HOME_ESCAPED}\\/:")")
            shift
        done
        shift
    fi

    local VERCMD="$1"
    shift

    cd $DIR || (echo "Can't find $DIR" 1>&2; exit 1)
    if test -d .git && $VERMILION_GIT_CMD fetch &> /dev/null; then
        $VERMILION_GIT_CMD pull -q
    else
        echo "Cannot git fetch $DIR"
        exit 1
    fi
    local HEAD_POS=$($VERMILION_GIT_CMD rev-parse HEAD)
    test -f "$VERMILION_FILE_LAST_SUCCESS" && [[ "$(cat "$VERMILION_FILE_LAST_SUCCESS")" == "$HEAD_POS" ]] && exit 0

    case "$VERCMD" in
        script)
            if test $# -gt 0
            then
                "$@"
            fi
            ;;
        cmake)
            local BUILD_DIR=".vermilion_cmake_build_files"
            local SRC_DIR="$1"
            shift
            if test ! -f "${BUILD_DIR}/CMakeCache.txt"; then
                cmake -B "${BUILD_DIR}" -S "${SRC_DIR}" -GNinja -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="$VERMILION_CFLAGS" -DCMAKE_CXX_FLAGS="$VERMILION_CXXFLAGS" || (rm -rf "${BUILD_DIR}"; exit 1)
            fi
            cmake --build "${BUILD_DIR}" "$@"
            ;;
        make)
            run_make "$@"
            ;;
        git)
            exit 0 # do nothing, only fetch updates
            ;;
        *)
            echo "[${DIR}] unknown option ${CMD}"
            exit 1
            ;;
    esac

    if test $? -eq 0
    then
        if test "${#POST_BUILD[@]}" -gt 0; then
            echo "${POST_BUILD[*]}" | bash
        fi
        echo -n "$HEAD_POS" > $VERMILION_FILE_LAST_SUCCESS
    else
        echo "[${DIR}] failed to upgrade."
    fi
}

run_depcheck() {
    local readonly AVAILABLE_LIBS=$(ldconfig -p | sed "s/\\s\+\([^ ]\+\)\\.so.*$/\1/;/^[^lib]/d" | sort -u)
    while read -r line || [[ -n "$line" ]]; do
        echo -n "$line" | awk '{print "[", $1, "] requires:"}'

        for dependency in $(echo -n "$line" | sed "s/^.* $TAG_DEP_BEGIN_ESC \(.\+\) ${TAG_DEP_END_ESC}.*\$/\\1/"); do
            echo -n " > $dependency, "
            local FOUND=$(echo "$AVAILABLE_LIBS" | grep "$dependency")
            if test -n "$FOUND"; then
                echo "found regex in:"
                for foundlib in $FOUND; do
                    echo "     - $foundlib"
                done
            else
                echo "not found!"
            fi
        done
    done
}

add_after_origin() {
    if test $# -gt 0
    then
        local DIR="$1"
        local ORIGIN="$2"
        shift 2
        echo "$DIR" "$ORIGIN" "$(cat)" "$@"
    fi
}

add_dependency() {
    local RE="^(.*) dep (.+) depend (.*)\$"
    if [[ "$(cat)" =~ $RE ]]
    then
        echo "${BASH_REMATCH[1]} dep ${BASH_REMATCH[2]} $* depend ${BASH_REMATCH[3]}"
    fi
}

func_main() {
    echo "Running [$1]..."
    local OUTPUTS=()
    local index=0

    while read -r line || [[ -n $line ]]
    do
        echo "${line}" | awk "{print \$1}"
        OUTPUTS[$index]="$("$1" ${line} 2>&1)"
        let index++
    done
    wait

    for output in $OUTPUTS
    do
        [[ -n $output ]] && \
            echo "$output"
    done
}

case "$VERMILION_TARGET" in
    help)
        usage && exit 0
        ;;
    add)
        CURRENT_DIR=$(get_dir_current)
        sed "/^$(echo "$CURRENT_DIR" | sed "s/[]\/\$*.^[]/\\\&/g")/d" \
            "$VERMILION_FILE_LIST" > "$VERMILION_FILE_LIST_TMP"
        echo "$CURRENT_DIR" "$($VERMILION_GIT_CMD config --get remote.origin.url)" "$@" | \
            cat - "$VERMILION_FILE_LIST_TMP" 2>/dev/null > $VERMILION_FILE_LIST
        rm "$VERMILION_FILE_LIST_TMP"
        ;;
    mark)
        test -f $VERMILION_FILE_LAST_SUCCESS && rm $VERMILION_FILE_LAST_SUCCESS
        ;;
    check)
        sed "${BASIC_ACCESS_SED};/ $TAG_DEP_BEGIN_ESC /!d" "$VERMILION_FILE_LIST" | run_depcheck
        ;;
    dep)
        sed "$BASIC_ACCESS_SED;/^$(get_dir_current | sed "s/[]\/\$*.^[]/\\\&/g")/d" \
            "$VERMILION_FILE_LIST" > "$VERMILION_FILE_LIST_TMP"
        sed "$BASIC_ACCESS_SED;/^$(get_dir_current | sed "s/[]\/\$*.^[]/\\\&/g")/!d" "$VERMILION_FILE_LIST_TMP" | \
            add_dependency "$@" | \
            cat - "$VERMILION_FILE_LIST_TMP" 2>/dev/null > $VERMILION_FILE_LIST
        ;;
    post*)
        CURRENT_DIR=$(get_dir_current)
        ESCAPED_NAME=$(echo "$CURRENT_DIR" | sed "s/[]\/\$*.^[]/\\\&/g")

        sed "$BASIC_ACCESS_SED;/^${ESCAPED_NAME}/d" \
            "$VERMILION_FILE_LIST" > "$VERMILION_FILE_LIST_TMP"
        cp "$VERMILION_FILE_LIST" "${VERMILION_FILE_LIST_TMP}2"
        echo "$TAG_POST_BEGIN" "$@" "$TAG_POST_END" | \
            add_after_origin $(sed "$BASIC_ACCESS_SED;s/ $TAG_POST_BEGIN_ESC .* $TAG_POST_END_ESC / /;/^${ESCAPED_NAME}/!d" "${VERMILION_FILE_LIST_TMP}2") | \
            cat - "$VERMILION_FILE_LIST_TMP" 2>/dev/null > $VERMILION_FILE_LIST
        rm "$VERMILION_FILE_LIST_TMP" "${VERMILION_FILE_LIST_TMP}2"
        ;;
    up*)
        sed "$BASIC_ACCESS_SED;s/ $TAG_DEP_BEGIN_ESC .* $TAG_DEP_END_ESC / /" "$VERMILION_FILE_LIST" | func_main upgrade
        ;;
    prep*)
        sed "$BASIC_ACCESS_SED;s/ $TAG_DEP_BEGIN_ESC .* $TAG_DEP_END_ESC / /" "$VERMILION_FILE_LIST" | func_main prepare
        ;;
    *)
        usage && exit 1
        ;;
esac

exit 0

